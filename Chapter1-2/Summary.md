
# 1 코틀린이란

- 자바 플랫폼에서 돌아가는 새로운 프로그래밍
- 간결하고 실용적
- 자바 코드와의 상호운용성을 중시

## 1.1 코틀린 주요 특성

### 1.1.1 대상 플랫폼
- 목적 : 현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것
- 일반적인 영역 : 서버상의 코드 / 안드로이드 디바이스에서 실행되는 모바일 애플리케이션
- 다른 영역 : iOS(인텔의 멀티 OS엔진을 사용), 데스크탑 애플리케이션(토네이도FX,자바FX), 자바스크립트로 코틀린 컴파일 가능

### 1.1.2 정적 타입 지정언어
- 정적 타입 지정 : 모든 프로그램 구성 요소의 타입을 `컴파일 시점`에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 `컴파일러가 타입을 검증해준다`라는 뜻
- 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다
- 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 `자동으로 유추`할 수 있기 때문에 프로그래머는 타입 선언을 생략해도 된다

```
var x = 1 // 변수의 타입이 Int임을 자동으로 유추
```
--> 타입 추론 기능(Type Inference)

- 장점
    - 성능 : 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠르다
    - 신뢰성 : 컴파일러가 `프로그램의 정확성을 검증`하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 적어진다
    - 유지 보수성 : 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다
    - 도구 지원 : 더 안전하게 `리팩토링`할 수 있고, 더 정확한 `코드 완성` 기능을 제공

- 새로운 점
    - 널이 될 수 있는 타입을 지원 : 컴파일 시점에 `널 포인터 예외`가 발생할 수 있는지 여부를 검사할 수 있어서 좀 더 프로그램의 `신뢰성`을 높일 수 있다
    - 함수 타입 지원 

- 동적 타입 지정 : 타입과 관계없이 모든 값을 변수에 넣을 수 있고, 메소드나 필드 접근에 대한 검증이 `실행 시점`에 일어나며, 그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용 (JVM(그루비, JRuby))


### 1.1.3 함수형 프로그래밍과 객체지향 프로그래밍

함수형 프로그래밍

- 일급 시민인 함수 : 함수를 `일반 값`처럼 다룰 수 있다. 함수를 `변수에 저장`할 수 있고, 함수를 `인자로 다른 함수에 전달`할 수 있으며, 함수에서 `새로운 함수를 만들어서 반환`할 수 있다.
- 불변성 : 내부 상태가 절대로 바뀌지 않는 `불변 객체`를 사용해 프로그램 작성
- 부수 효과 없음 : 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 `순수 함수`를 사용

장점

- 간결성 : 함수를 값처럼 활용할 수 있으면 더 강력한 추상화를 할 수 있고 강력한 추상화를 사용해 코드 중복을 막을 수 있다
- 다중 스레드를 사용해도 안전 : 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다. 따라서 복잡한 동기화를 적용하지 않아도 된다
- 테스트 하기 쉽다 : 준비 코드 없이 독립적으로 테스트할 수 있다

코틀린의 함수형 프로그래밍 지원

- 함수 타입을 지원함에 따라 `어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환`할 수 있다
- `람다 식을 지원`함에 따라 번거로운 준비 코드를 작성하지 않아도 코드 블록을 쉽게 정의하고 여기저기 전달 가능
- 데이터 클래스는 `불변적인 값 객체`를 간편하게 만들 수 있는 구문을 제공
- 코틀린 표준 라이브러리는 `객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API제공`

- 함수형 프로그래밍을 지원하지만 강제하지는 않는다

## 1.2 코틀린 응용

### 1.2.1 서버 프로그래밍

응용 분야

- 브라우저에 HTML 페이지를 돌려주는 웹 애플리케이션
- 모바일 어플리케이션에게 HTTP를 통해 JSON API를 제공하는 백엔드 에플리케이션
- RPC 프로토콜을 통해 서로 통신하는 작은 서비스들로 이뤄진 마이크로 서비스

자바 코드와 매끄럽게 상호운용할 수 있다

- 코틀린은 새로운 컴포넌트를 작성하거나 기존 서비스 코드를 코틀린으로 이식해야 하는 경우 모두 잘 들어맞는다
- 자바 클래스를 코틀린으로 확장해도 아무런 문제가 없으며, 코틀린 클래스 안의 메소드나 필드에 특정 (자바) 애노테이션을 붙여야 하는 경우에도 아무런 문제가 없다
- 코틀린의 빌더 패턴 활용 : 간결한 구문을 사용해 객체로 이뤄진 그래프를 쉽게 구축하면서도 코틀린이 제공하는 완전한 추상화와 코드 재활용을 지속적으로 누릴 수 있다


### 1.2.2 안드로이드 프로그래밍

- 안코 라이브러리 : 수많은 안드로이드 API에 대한 코틀린 어댑터를 제공받을 수 있다
- 코틀린 타입 시스템은 null 값을 정확히 추적하며 널 포인터로 인해 생기는 문제를 줄여준다
- 코틀린 컴파일러가 생성한 바이트코드는 일반적인 자바 코드와 똑같이 효율적으로 실행 
- 대부분의 코틀린 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝

## 1.3 코틀린의 철학

자바와의 `상호운용성`에 초점을 맞춘 `실용적`이고 `간결`하며 `안전한` 언어

### 1.3.1 실용성
- 실제 문제를 해결하기 위해 만들어진 실용적인 언어
- 수많은 소프트웨어 개발자들의 사용에 잘 들어맞을 수 있게 주의 깊게 언어 특성을 선택
- 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존
- `도구를 강조` : 더 간결한 구조로 바꿀 수 있는 대부분의 코드 패턴을 도구가 자동으로 감지해서 수정하라고 제안 

### 1.3.2 간결성
- 코드가 더 간단하고 간결할수록 내용을 파악하기가 더 쉽다
- 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 자바에 존재하는 여러 가지 번거로운 준비 코드를 코틀린은 `묵시적으로 제공`하기 때문에 코틀린 소스코드는 그런 준비 코드로 인해 지저분해지는 일이 없다
- `람다를 지원` : 작은 코드 블ㄹ록을 라이브러리 함수에 쉽게 전달할 수 있다
- 언어가 제공하지 않는 연산자를 프로그래머가 정의할 수 있게 허용하지 않는다

### 1.3.3 안전성
- 컴파일 시점 검사를 통해 오류를 더 많이 방지해준다
- 코틀린은 프로그램의 NullPointerException을 없애기 위해 노력
- 코틀린 타입 시스템은 null이 될 수 없는 값을 추적하며, 이로 인해 추가로 들어가는 비용을 미미하다
- 어떤 타입이 널이 될 수 있는지 여부를 표시하기 위해 오직 `?` 한 글자만 추가하면 된다

```
val s: String? = null
val s2: String = ""
```

- 이러한 기능은 애플리케이션이 NullPointerException으로 인해 갑자기 중단되는 경우를 많이 줄여준다

- ClassCastException : 어떤 객체를 다른 타입으로 캐스트하기 전에 타입을 미리 검사하기 하지 않으면 ClassCastException이 발생할 수도 있다
- 코틀린에서는 타입 검사와 캐스트가 한 연산자에 의해 이뤄진다
- 어떤 객체의 타입을 검사했고 그 객체가 그 타입에 속한다면 해당 타입의 메소드나 필드 등의 멤버를 별도의 캐스트 없이 사용할 수 있다

```
if(value is String) 
    println(value.toUpperCase())
```

### 1.3.4 상호운용성
- 라이브러리가 어떤 API를 제공하던 간에 코틀린에서 그 API를 활용 할 수 있다
- 자바 메소드를 호출하거나 자바 클래스를 상속하거나 인터페이스를 구현하거나 자바 애노테이션을 코틀린 코드에 적용 가능
- 코틀린의 클래스나 메소드를 일반적인 자바 클래스나 메소드와 똑같이 사용 가능
- 기존 자바 라이브러리를 가능하면 최대한 활용한다는 점

가능한 동작
- 자바와 코틀린 소스 파일을 자유롭게 내비게이션 할 수 있다
- 여러 언어로 이뤄진 프로젝트를 디버깅하고 서로 다른 언어로 작성된 코드를 언어에 관계없이 한 단계씩 실행할 수 있다
- 자바 메소드를 리팩토링해도 그 메소드와 관련 있는 코틀린 코드까지 제대로 변경된다. 

## 1.4 코틀린 도구 사용

### 1.4.1 코틀린 코드 컴파일

---------

# 2 코틀린 기초

변수, 함수, 클래스, 프로퍼티, 제어구조, 스마트 캐스트, 예외 처리

## 2.1 함수와 변수

- 함수를 선언할 때 fun 키워드 사용
- 파라미터 이름 뒤에 그 파라미터 타입을 쓴다
- 함수를 최상위 수준에 정의 가능
- 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다
- System.out.println 대신에 println이라고 쓴다
- 세미콘론(;)을 붙이지 않아도 좋다

### 2.1.1 함수

- 함수 선언은 fun 키워드로 시작
- fun 다음에 함수 이름이 온다
- 함수 이름 뒤에는 괄호 안에 파라미터 목록
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 온다
- 괄호와 반환 타입 사이를 클론(:)으로 구분

```
fun max(a: Int, b: Int): Int{
    return if (a > b) a else b
}
```

> 문(statement)와 식(expression)의 구분
코틀린에서 if는 식이지 문이 아니다. 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존대하며 아무련 값을 만들어내지 않는다는 차이가 있다

식이 본문인 함수

- return을 제거하면 등호(=)를 식 앞에 붙이면 더 간결하게 함수를 표현할 수 있다

```
fun max(a: Int, b: Int): Int = if(a > b) a else b
```

- 본문이 중괄호로 둘러싸인 함수 : 블록이 본문인 함수
- 등호와 식으로 이뤄진 함수를 : 식이 본문인 함수
- 식이 본문인 함수의 반환 타입만 생략 가능

### 2.1.2 변수

- 타입 지정을 생략하는 경우가 흔하기 때문에 변수 이름 뒤에 타입을 명시하거나 생략하게 허용

```
val question = 
    "배고플까요?"

val answer = 42
```

- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다

변경 가능한 변수와 변경 불가능한 변수

- val - 변경 불가능한 참조를 저장하는 변수
val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다.
- var - 변경 가능한 참조
바뀔 수 있다

- 변경 불가능한 참조와 변경 불가능 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다

### 2.1.3 문자 템플릿
```
fun main(args: Array<String>){
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```

- 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다
- 복잡한 식도 중괄호를 둘러싸서 문자열 템플릿 안에 넣을 수 있다

```
fun main(args: Array<String>){
    if (args.size > 0) 
        println("Hello, ${args[0]}!")
}
```

- 중괄호를 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다

## 2.2 클래스와 프로퍼티

- 코틀린을 활용하면 더 적은 양의 코드로 클래스와 관련 있는 대부분의 작업을 수행 할 수 있다
- 코드가 없이 데이터만 저장하는 클래스 : 값 객체
- public 가시성 변경자가 사라졌다

### 2.2.1 프로퍼티
- 자바의 필드와 접근자 메소드를 완전히 대신
```
class Person{
    val name: String,
    var isMarried: Boolean
}
```

- 기본적으로 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것
- 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하기 위한 세터, 필드에 값을 읽기 위한 게터로 이뤄진 간단한 디폴트 접근자 구현을 제공한다

```
println(person.name)
```
- 게터를 호출하는 대신 프로퍼티를 직접 사용했음에 유의
- 세터 : person.isMarried = false

### 2.2.2 커스텀 접근자
```
class Rectangle(val height: Int, val width: Int){
    val isSquare: Boolean
        get() {
            return height == width
        }
}
```
- 프로퍼티의 접근자를 직접 작성하는 방법
- 별도의 필드에 저장할 필요 없이 그때그때 알 수 있게 해준다

### 2.2.3 코틀린 소스코드 구조 :디렉터리와 패키지

- 모든 코틀린 파일의 맨 앞에 pacakage문을 넣을 수 있다
- 그 파일 안에 있는 모든 선언(클래스, 함수, 프로퍼티 등)이 해당 패키지에 들어간다
- 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다
- 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다
- 디스크 상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계 없다

## 2.3 선택 표현과 처리 : enum과 when

- when은 자바의 switch를 대치하되 훨씬 더 강력하며, 앞으로 더 자주 사용할 프로그래밍 요소라고 생각할 수 있다
- when을 설명하는 과정에 enum을 선언하는 방법과 스마트 캐스트에 대해서 살펴본다

### 2.3.1 enum 클래스 정의
```
enum class Color{
    RED, ORAGNE, YELLOW, GREEN, BLUE, INDIGO, VLOLET
}
```
- enum은 자바 선언보다 코틀린 선언에 더 많은 키워드를 써야 하는 흔치 않는 예다
- 코틀린에서는 enum class를 사용하고 enum을 소프트 키워드라 부르는 존재다
- 단순히 값만 열거하는 존재가 아니다. enum 클래스 안에도 프로퍼티나 메소드를 정의 할 수 있다.

```
enum class Color(
    val r: Int, val g: Int, val b : Int
) {
    RED(255, 0, 0), ORANGE(255, 165, 0),

}
```
- enum 클래스 안에 메소드를 정의 하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야 한다

### 2.3.2 when으로 enum 클래스 다루기
- 자바의 switch문에 해당하는 코틀린 구성 요소는 when이다
- if문과 마찬가지로 when도 값을 만들어내는 식이다
- 따라서 식이 본문인 함수에 when을 바로 사용할 수 있다

```
코드
```

- 자바와 달리 각 분기의 끝에 break를 넣지 않아도 된다

### 2.3.3 when과 임의의 객체를 함께 사용
- 코틀린에서 when은 자바의 switch보다 훨씬 더 강력
- 코틀린 when의 분기 조건은 임의의 객체를 허용
- 코틀린 표준 라이브러리에는 인자로 전달받은 여러 객체를 그 객체들을 포함하는 집합인 set 객체로 만드는 setOf라는 함수가 있다
- 집합은 원소가 모여 있는 컬렉션으로, 분기 조건에 있는 객체 사이를 매치할 때 동등성을 사용한다

### 2.3.4 인자 없는 when 사용
- when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다

### 2.3.5 스마트 캐스트 : 타입 검사와 타입 캐스트를 조합
- 인코딩 하는 방법을 생각해야 한다
- 식을 트리 구조로 저장
- 노드는 합계나 수 중 하나
- num은 항상 말단 노드이지만, sum은 자식이 둘 있는 중간 노드
- 식을 위한 Expr 인터페이스가 있고, sum과 num클래스는 그 Expr 인터페이스를 구현한다

```
interface Expr
class Num(val value: Int) :  Expr
class Sum(val left: Expr, val right: Expr) :  Expr
```
- Sum은 Expr의 왼쪽과 오른쪽 인자에 대한 참조를 left와 right 프로퍼티로 저장
- left와 right는 각각 Num이나 Sum일 수 있다
- (1+2)+4라는 식을 저장하면 Sum(Sum(Num(1),Num(2)),Num(4))라는 구조의 객체가 생긴다
- Expr 인터페이스는 두 가지 구현 클래스가 존재한다
- 따라서 식을 평가하려면 두 가지 경우를 고려해야 한다
    - 어떤 식의 수라면 그 값을 반환한다
    - 어떤 식이 합계라면 좌항과 우항의 값을 계산한 다음에 그 두 값을 합한 값을 반환한다
- 코틀린은 is를 사용해 변수 타입을 검사한다
- is 검사는 자바의 instanceof와 비슷하다
- 자바에서는 어떤 변수의 타입을 instanceof로 확인한 다음에 그 타입에 속한 멤버에 접근하기 위해서는 명시적으로 변수 타입을 캐스팅해야 한다
- 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅을 해준다
- 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅 하지도 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다 --> 스마트 캐스트
- 스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동
- 원하는 타입으로 명시적으로 타입 캐스팅하려면 as키워드를 사용한다

### 2.3.6 리팩토링 : if를 when으로 변경
- 값의 타입을 검사하는 when 분기도 가능하다

### 2.3.7 if와 when의 분기에서 블록 사용
- if나 when 모두 분기에 블록을 사용할 수 있다
- 블록의 마지막 문장이 블록 전체의 결과가 된다
- 맨 마지막에 분기의 결과 값을 위치시키면 된다
- 이 규칙은 함수에 대해서는 성립하지 않는다.
- 식이 본문인 함수는 블록 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return문이 반드시 있어야 한다

## 2.4 대상을 이터레이션 : while과 for 루프
- 코틀린 특성 중 자바와 가장 비슷한 것이 이터레이션이다

### 2.4.1 while 루프
- 자바와 다르지 않다

### 2.4.2 수에 대한 이터레이션 :  범위와 수열
- 코틀린은 가장 흔한 용례인 초깂값, 증가 값, 최종 값을 사용한 루프를 대신하기 위해 범위를 사용한다
- 범위는 기본적으로두 값으로 이뤄진 구간이다
- 보통은 그 두 값은 정수 등의 숫자 타입의 값이며 `..` 연산자로 시작 값과 끝 값을 연결해서 범위를 만든다

```
val oneToTen = 1..10
```

- 수열 : 어떤 범위에 속한 값을 일정한 순서로 이터레이션 하는 경우
- step : 증가 값
- downTo : 역방향 수열
- until : 끝 값을 포함하지 않는 범위

### 2.4.3 맵에 대한 이터레이션
- 맵 : 키/값 쌍을 원소로 하는 컬렉션

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사
- in 연산자를 사용해 어떤 값이 범위에 속하는지 검사
- !in 은 어떤 값이 범위에 속하지 않는지 검사
- in 또는 !in은 when 식에서 사용해도 된다
- 범위는 문자에만 국한되지 않고 비교 가능한 클래스라면 가능

## 2.5 코틀린의 예외 처리
- 코틀린의 예외 처리는 자바나 다른 언어의 예외 처리와 비슷하다
- 함수는 정상적으로 종료할 수 있지만 오류가 발생하면 예외를 던질 수 있다

```
if (percentage !in 0..100){
    throw IllegalArgumentException(
        "A percentage value must be between 0 and 100 : $percentage")
}
```

### 2.5.1 try, catch, finally
- 에외를 처리하려면 try와 catch, finally절을 함께 사용
- 자바와 큰  차이는 throws 절이 코드에 없다는 점
- 자바는 체크 예외를 명시적으로 처리
- 코틀린은 체크 예외와 언체크 예외를 구별하지 않는다
- 코틀린에서는 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다

### 2.5.2 try를 식으로 사용
- 코틀린의 try 키워드는 if나 when과 마찬가지로 식이다
- try의 값을 변수에 대입할 수 있다
- try의 본문은 반드시 중괄호 {}로 둘러싸야 한다
- try 코드 블록의 실행이 정상적으로 끝나면 그 블록의 마지막 식의 값이 결과이고, 예외가 발생하고 그 예외에 해당하는 catch 블록의 값이 결과다

